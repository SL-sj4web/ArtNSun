<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Vantail haut de gamme - Baie vitr√©e 3D</title>
  <style>
    body { margin: 0; background: #ffffff; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="three-canvas"></canvas>
  <script type="module">
    import * as THREE from './libs/three.module.js';
    import { OrbitControls } from './libs/OrbitControls.js';
    import { RGBELoader } from './libs/RGBELoader.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(1.5, 2.2, 3.5);
    camera.lookAt(0, 1, 0);

    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.physicallyCorrectLights = true;
    renderer.shadowMap.enabled = true;

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(2, 5, 3);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const floorGeo = new THREE.PlaneGeometry(10, 10);
    const floorMat = new THREE.ShadowMaterial({ opacity: 0.15 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    floor.receiveShadow = true;
    scene.add(floor);

    const largeur = 1;
    const hauteur = 2.1;
    const epaisseur = 0.05;
    const cadreEpaisseur = 0.05;

    const cadreColor = new THREE.Color('#3f3f3f');
    const cadreMat = new THREE.MeshStandardMaterial({ color: cadreColor, metalness: 1, roughness: 0.25 });

    const group = new THREE.Group();

    const montantGeo = new THREE.BoxGeometry(cadreEpaisseur, hauteur, epaisseur);
    const montantG = new THREE.Mesh(montantGeo, cadreMat);
    montantG.position.set(-largeur / 2 + cadreEpaisseur / 2, hauteur / 2, 0);
    montantG.castShadow = true;
    group.add(montantG);
    const montantD = montantG.clone();
    montantD.position.x = largeur / 2 - cadreEpaisseur / 2;
    group.add(montantD);

    const traverseGeo = new THREE.BoxGeometry(largeur - 2 * cadreEpaisseur, cadreEpaisseur, epaisseur);
    const traverseH = new THREE.Mesh(traverseGeo, cadreMat);
    traverseH.position.set(0, hauteur - cadreEpaisseur / 2, 0);
    traverseH.castShadow = true;
    group.add(traverseH);
    const traverseB = traverseH.clone();
    traverseB.position.y = cadreEpaisseur / 2;
    group.add(traverseB);

    const glassGeo = new THREE.PlaneGeometry(largeur - 2 * cadreEpaisseur, hauteur - 2 * cadreEpaisseur);

    const glassMat = new THREE.MeshPhysicalMaterial({
      color: 0xffffff,
      metalness: 0,
      roughness: 0.05,
      transmission: 1,
      transparent: true,
      opacity: 1,
      ior: 1.52,
      thickness: 0.02,
      reflectivity: 0.4,
      clearcoat: 1,
      clearcoatRoughness: 0.05,
      side: THREE.DoubleSide,
      envMapIntensity: 1.5
    });

    const glass = new THREE.Mesh(glassGeo, glassMat);
    glass.position.set(0, hauteur / 2, 0.005);
    group.add(glass);

    scene.add(group);

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    new RGBELoader()
      .setDataType(THREE.UnsignedByteType)
      .load('./libs/studio_small_03_1k.hdr', function (texture) {
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        const envMap = pmremGenerator.fromEquirectangular(texture).texture;
        scene.environment = envMap;
        texture.dispose();
        pmremGenerator.dispose();
        animate();
      }, undefined, function () {
        console.warn('HDRI loading failed, using fallback background');
        animate();
      });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
